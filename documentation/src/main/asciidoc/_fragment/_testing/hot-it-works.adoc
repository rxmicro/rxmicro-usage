:FRAGMENT_RELATIVE_DIR: ../
include::../___fragment-settings.adoc[]

[[testing-how-it-works-section]]
=== How It Works

Java 9 has introduced the {WHAT-IS-JPMS-LINK}[`JPMS`^].

This system requires that a developer defines the `module-info.java` descriptor for each project.
In this descriptor, the developer must describe all the dependencies of the current project.
In the context of the unit module system, the tests required for each project should be configured as a separate module, since they depend on libraries that should not be available in the `runtime`.
Usually such libraries are unit testing libraries (e.g. https://junit.org/junit5/[JUnit 5^]), mock creation libraries (e.g. https://site.mockito.org/[Mockito^]), etc.

When trying to create a separate `module-info.java` descriptor available only for unit tests, many modern IDEs report an error.

*Therefore, the simplest and most common solution to this problem is to organize unit tests in the form of
https://www.logicbig.com/tutorials/core-java-tutorial/modules/automatic-modules.html[automatic module^]. +
This solution allows You to correct compilation errors, but when starting tests, there will be runtime errors. +
To fix runtime errors, when starting the Java virtual machine, You must add
https://nipafx.dev/five-command-line-options-hack-java-module-system/[options that configure the Java module system at runtime^].*

In case the tests are run, these options must be added to the `maven-surefire-plugin`:

[source,xml]
----
<plugin>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>2.22.1</version>
    <configuration>
        <argLine>
            @{argLine}
            --add-exports ...
            --add-opens ...
            --patch-module ...
            --add-modules ...
            --add-reads ...
        </argLine>
    </configuration>
</plugin>
----

The specified configuration options for the Java module system at runtime can also be added using the features of the
{JDK-JAVA-BASE-DOC-ROOT-URL}java/lang/Module.html[`java.lang.Module`^] class.

*In order the developer is relieved of the need to add the necessary options to the `maven-surefire-plugin` configuration, the RxMicro framework provides a special
`io.rxmicro.annotation.processor.RxMicroTestsAnnotationProcessor` component.*

To activate this component, it is necessary to add a new execution to the `maven-compiler-plugin` configuration:

[source,xml]
----
<execution>
    <id>test-compile</id>
    <goals>
        <goal>testCompile</goal> <!--1-->
    </goals>
    <configuration>
        <annotationProcessors>
            <annotationProcessor>
                io.rxmicro.annotation.processor.RxMicroTestsAnnotationProcessor <!--2-->
            </annotationProcessor>
        </annotationProcessors>
        <generatedTestSourcesDirectory>
            ${project.build.directory}/generated-test-sources/  <!--3-->
        </generatedTestSourcesDirectory>
    </configuration>
</execution>
----
<1> The separate configuration is required for the tests, so a new `execution` must be added.
<2> The annotation processor class that handles the test configuration.
<3> Location of Java classes generated by the `RxMicro Test Annotation Processor`.

This annotation processor generates one single `rxmicro.$$ComponentTestFixer` class, that automatically opens access to all packages of the current project to unnamed modules:

[source,java]
----
public final class $$ComponentTestFixer {

    static {
        final Module currentModule = $$ComponentTestFixer.class.getModule();
        currentModule.addExports("rxmicro", RX_MICRO_REFLECTION_MODULE);
    }

    public $$ComponentTestFixer() {
        final Module currentModule = getClass().getModule();
        if (currentModule.isNamed()) {
            logInfoTestMessage("Fix the environment for componnet test(s)...");
            final Module unnamedModule = getClass().getClassLoader().getUnnamedModule(); // <1>
            final Set<Module> modules = unmodifiableOrderedSet(
                    unnamedModule, RX_MICRO_REFLECTION_MODULE
            );
            for (final Module module : modules) {
                for (final String packageName : currentModule.getPackages()) {
                    currentModule.addOpens(packageName, module); // <2>
                    logInfoTestMessage(
                            "opens ?/? to ?", // <3>
                            currentModule.getName(),
                            packageName,
                            module.isNamed() ? module.getName() : "ALL-UNNAMED"
                    );
                }
            }
        }
    }
}
----
<1> Using the standard Java API, the RxMicro framework retrieves the references to the current and unnamed modules.
<2> Using the features of the {JDK-JAVA-BASE-DOC-ROOT-URL}java/lang/Module.html[`java.lang.Module`^] class, the RxMicro framework opens the full access to all classes from all packages from the current module.
<3> To inform the developer about the successful performance of the  `rxmicro.$$ComponentTestFixer` class, the RxMicro framework displays to the console the information that access was successfully provided.

[NOTE]
====
When running different types of tests, sometimes a different configuration of the Java module system is required.
Thus, for each type of test, the RxMicro framework creates a separate class in the `rxmicro` system package:

.Names of generated classes
[cols="1,1"]
|===
|*Test type*|*Name of the generated class*

|REST-based microservice test
|`$$RestBasedMicroServiceTestFixer`

|Component unit test
|`$$ComponentTestFixer`

|REST-based microservice integration test
|`$$IntegrationTestFixer`
|===
====

Before starting tests, the RxMicro framework uses a generated class to configure the module system for the test environment:

[source,text,subs="verbatim,quotes"]
----
[INFO] -------------------------------------------------------
[INFO]  *T E S T S*
[INFO] -------------------------------------------------------
...
[INFO] Fix the environment for component test(s)...
[INFO] *opens* examples.testing/io.rxmicro.examples.testing to ALL-UNNAMED # <1>
[INFO] *opens* examples.testing/rxmicro to ALL-UNNAMED
[INFO] Running *io.rxmicro.examples.testing.ParentComponent1Test* # <2>
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 0.278 s
[INFO] Running *io.rxmicro.examples.testing.ParentComponent2Test*
[INFO] Tests run: 1, Failures: 0, Errors: 0, Skipped: 0, Time elapsed: 1.378 s
[INFO]
[INFO] Results:
[INFO]
[INFO] Tests run: 2, Failures: 0, Errors: 0, Skipped: 0
[INFO]
[INFO] ------------------------------------------------------------------------
[INFO] *BUILD SUCCESS*
[INFO] ------------------------------------------------------------------------
----
<1> All packages of the current module are opened before starting tests.
<2> After configuring the module system for the test environment, Unit tests are started.

*Thus, for the successful writing of tests using the RxMicro framework, besides adding the required libraries, do not forget to configure the `maven-compiler-plugin` by adding the following annotation processor for the test environment: `io.rxmicro.annotation.processor.RxMicroTestsAnnotationProcessor`.*
