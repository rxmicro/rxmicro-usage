:FRAGMENT_RELATIVE_DIR: ../
include::../___fragment-settings.adoc[]

[[core-dont-block-current-thread]]
=== Don’t Block Current Thread!

В современной архитектуре компьютера IO операции являются самыми медленными.
В результате чего при использовании
https://en.wikipedia.org/wiki/Multithreading_(computer_architecture)[потокового программирования^]
CPU и RAM используются крайне неэффективно.
Для однопользовательского монолитного приложения данная неэффективность незаметна.
Однако в случае многопользовательского распределенного приложения, где количество IO операций на порядок выше, данная проблема порождает огромные финансовые затраты на дополнительное аппаратное обеспечение и координацию между клиентскими потоками данных (https://en.wikipedia.org/wiki/C10k_problem[C10k problem^]).

Поэтому для эффективного использования аппаратных ресурсов многопользовательского распределенного приложения в настоящее время используется https://en.wikipedia.org/wiki/Event-driven_architecture[Event-driven architecture (EDA)^].

The most popular Java framework, который использует Event-driven architecture для IO операций является https://netty.io[Netty^].
Для написания эффективных программ с помощью Netty, необходимо следовать определенным правилам и ограничениям.
Самым главным из них является требование: *Don’t block current thread!*

The RxMicro framework is a framework, который функционирует на базе Netty.
Поэтому все требования к приложениям, использующим Netty, распространяются и на the RxMicro framework.

==== Prohibited Operations

Поэтому при написании микросервисных приложений на базе the RxMicro framework, *запрещены* следующие операции:

* Чтение данных из сокета или файла в блокирующем стиле, используя `java.io.InputStream` и классы наследники.
* Запись данных в сокета или в файл в блокирующем стиле, используя `java.io.OutputStream` и классы наследники.
* Взаимодействие с базой данных с помощью блокирующего драйвера (все `JDBC` драйверы).
* Ожидание на локе или мониторе (`java.util.concurrent.locks.Lock`, `Object.wait`).
* Перевод потока в режим сна (`Thread.sleep`, `TimeUnit.sleep`).
* любые другие https://en.wikipedia.org/wiki/Blocking_(computing)[*блокирующие операции*^].

==== Recommended Approach

Отсутствие блокирующих операций в микросервисе позволяет обслуживать огромное количество конкурентных соединений, используя небольшое количество потоков и как следствие эффективно использовать аппаратные ресурсы компьютера.

Поэтому при проектировании микросервисов via the RxMicro framework необходимо следовать следующему правилу:

*При реализации микросервиса если результат может быть получен немедленно, он должен быть возвращен немедленно.*

*В противном случае необходимо возвратить
https://github.com/reactive-streams/reactive-streams-jvm/blob/v1.0.3/README.md#specification[Publisher^] or
{JDK-JAVA-BASE-DOC-ROOT-URL}java/util/concurrent/CompletableFuture.html[CompletableFuture^], которые сгенерируют результат позже.*
